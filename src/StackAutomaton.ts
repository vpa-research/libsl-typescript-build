// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - ohos/util/Stack.lsl:26
//  - ohos/util/Stack.main.lsl:17
//
import {LSL_ListIterator} from './LSL_ListIterator';
import {LSL_ListIteratorAutomaton} from './LSL_ListIteratorAutomaton';
import {libsl} from './libsl_runtime';
import {Stack} from '@ohos.util.Stack';
import {Approximate} from '@org.jacodb.approximation.annotation';
import {Engine, SymbolicList} from '@org.usvm.api';


/**
 * StackAutomaton for LSL_Stack<T> ~> Stack@@ohos.util.Stack */
@Approximate(/* value */ Stack)
export class StackAutomaton<T> {

    storage: SymbolicList<T> = libsl.ANYTHING;

    public constructor() {
        if (libsl.constructor_called_by_user) {
            // body
            if (!(this instanceof Stack)) {
                throw libsl.new_ERROR("BusinessError", 10200012, "The Stack\'s constructor cannot be directly invoked.");
            }
            this.storage = Engine.makeSymbolicList();
        }
    }

    /**
     * [FUNCTION] StackAutomaton::push(LSL_Stack<?::T>, ?::T) -> boolean
     * Source: ohos/util/Stack.main.lsl:68 */
    push(element: T): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The push method cannot be bound.";
            if (!(this instanceof Stack)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            this.storage.insert(this.storage.size(), element);
            result = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StackAutomaton::pop(LSL_Stack<?::T>) -> ?::T | undefined
     * Source: ohos/util/Stack.main.lsl:78 */
    pop(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The pop method cannot be bound.";
            if (!(this instanceof Stack)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            const pos: number = this.storage.size() - 1;
            if (pos === -1) {
                result = undefined;
            }
            else {
                result = this.storage.get(pos);
                this.storage.remove(pos);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] StackAutomaton::peek(LSL_Stack<?::T>) -> ?::T | undefined
     * Source: ohos/util/Stack.main.lsl:96 */
    peek(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The peek method cannot be bound.";
            if (!(this instanceof Stack)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            const pos: number = this.storage.size() - 1;
            if (pos === -1) {
                result = undefined;
            }
            else {
                result = this.storage.get(pos);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] StackAutomaton::locate(LSL_Stack<?::T>, ?::T) -> number
     * Source: ohos/util/Stack.main.lsl:109 */
    locate(element: T): number {
        let result: number = 0;
        /* body */ {
            const msg: string = "The locate method cannot be bound.";
            if (!(this instanceof Stack)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            const size: number = this.storage.size();
            if (size === 0) {
                result = -1;
            }
            else {
                result = libsl.ListActions.find(this.storage, element, 0, size);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] StackAutomaton::forEach(LSL_Stack<?::T>, Stack_Consumer<?::T>, Object) -> void
     * Source: ohos/util/Stack.main.lsl:122 */
    forEach(callbackFn: (value: T, index?: number, queue?: Stack<T>) => void, thisArg?: Object) {
        /* body */ {
            const msg: string = "The forEach method cannot be bound.";
            if (!(this instanceof Stack)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let i: number = 0;
            for (i = 0; i < this.storage.size(); i += 1) {
                const item: T = this.storage.get(i);
                callbackFn.call(thisArg, item, i, this);
            }
        }
    }

    /**
     * [FUNCTION] StackAutomaton::isEmpty(LSL_Stack<?::T>) -> boolean
     * Source: ohos/util/Stack.main.lsl:141 */
    isEmpty(): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The isEmpty method cannot be bound.";
            if (!(this instanceof Stack)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.storage.size() === 0;
        }
        return result;
    }

    /**
     * [FUNCTION] StackAutomaton::[Symbol.iterator](LSL_Stack<?::T>) -> IterableIterator<?::T>
     * Source: ohos/util/Stack.main.lsl:150 */
    [Symbol.iterator](): IterableIterator<T> {
        let result: IterableIterator<T> = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The Symbol.iterator method cannot be bound.";
            if (!(this instanceof Stack)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na0 = new LSL_ListIteratorAutomaton<T>();
            // lsl$na0.__$state = Initialized;
            lsl$na0.container = this;
            lsl$na0.cursor = 0;
            result = lsl$na0 as any as LSL_ListIterator<T>;
        }
        return result;
    }

    /**
     * [FUNCTION] StackAutomaton::length(LSL_Stack<?::T>) -> number
     * Source: ohos/util/Stack.main.lsl:164 */
    get length(): number {
        let result: number = 0;
        /* body */ {
            result = this.storage.size();
        }
        return result;
    }

}
