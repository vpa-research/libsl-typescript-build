// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - ohos/util/PlainArray.lsl:27
//  - ohos/util/PlainArray.main.lsl:17
//
import {PlainArrayAutomaton as PlainArrayAutomaton_} from './PlainArrayAutomaton';
import {PlainArray_Iterator_tupleKV} from './PlainArray_Iterator_tupleKV';
import {PlainArray_Iterator_tupleKV_Automaton} from './PlainArray_Iterator_tupleKV_Automaton';
import {libsl} from './libsl_runtime';
import {PlainArray} from '@ohos.util.PlainArray';
import {Approximate} from '@org.jacodb.approximation.annotation';
import {Engine, SymbolicList} from '@org.usvm.api';


/**
 * PlainArrayAutomaton for LSL_PlainArray<T> ~> PlainArray@@ohos.util.PlainArray */
@Approximate(/* value */ PlainArray)
export class PlainArrayAutomaton<T> {

    keysStorage: SymbolicList<number> = libsl.ANYTHING;

    valuesStorage: SymbolicList<T> = libsl.ANYTHING;

    public constructor() {
        if (libsl.constructor_called_by_user) {
            // body
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200012, "The PlainArray\'s constructor cannot be directly invoked.");
            }
            this.keysStorage = Engine.makeSymbolicList();
            this.valuesStorage = Engine.makeSymbolicList();
        }
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::isEmpty(LSL_PlainArray<?::T>) -> boolean
     * Source: ohos/util/PlainArray.main.lsl:84 */
    isEmpty(): boolean {
        let result: boolean = false;
        /* body */ {
            let msg: string = "The isEmpty method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.keysStorage.size() === 0;
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::has(LSL_PlainArray<?::T>, number) -> boolean
     * Source: ohos/util/PlainArray.main.lsl:93 */
    has(key: number): boolean {
        let result: boolean = false;
        /* body */ {
            let msg: string = "The has method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let size: number = this.keysStorage.size();
            if (size === 0) {
                result = false;
            }
            else {
                result = libsl.ListActions.find(this.keysStorage, key, 0, size) !== -1;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::get(LSL_PlainArray<?::T>, number) -> ?::T | undefined
     * Source: ohos/util/PlainArray.main.lsl:106 */
    get(key: number): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The get method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let size: number = this.keysStorage.size();
            if (size === 0) {
                result = undefined;
            }
            else {
                Engine.assume(size > 0);
                let index: number = libsl.ListActions.find(this.keysStorage, key, 0, size);
                result = this.valuesStorage.get(index);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::getIndexOfKey(LSL_PlainArray<?::T>, number) -> number
     * Source: ohos/util/PlainArray.main.lsl:125 */
    getIndexOfKey(key: number): number {
        let result: number = 0;
        /* body */ {
            let msg: string = "The getIndexOfKey method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let size: number = this.keysStorage.size();
            if (size === 0) {
                result = -1;
            }
            else {
                result = libsl.ListActions.find(this.keysStorage, key, 0, size);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::getIndexOfValue(LSL_PlainArray<?::T>, ?::T) -> number
     * Source: ohos/util/PlainArray.main.lsl:138 */
    getIndexOfValue(value: T): number {
        let result: number = 0;
        /* body */ {
            let msg: string = "The getIndexOfValue method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let size: number = this.valuesStorage.size();
            if (size === 0) {
                result = -1;
            }
            else {
                result = libsl.ListActions.find(this.valuesStorage, value, 0, size);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::getKeyAt(LSL_PlainArray<?::T>, number) -> number
     * Source: ohos/util/PlainArray.main.lsl:151 */
    getKeyAt(index: number): number {
        let result: number = 0;
        /* body */ {
            let msg: string = "The getKeyAt method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if ((index < 0) || (this.keysStorage.size() <= index)) {
                result = -1;
            }
            else {
                result = this.keysStorage.get(index);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::getValueAt(LSL_PlainArray<?::T>, number) -> ?::T | undefined
     * Source: ohos/util/PlainArray.main.lsl:164 */
    getValueAt(index: number): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The getValueAt method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if ((index < 0) || (this.valuesStorage.size() <= index)) {
                result = undefined;
            }
            else {
                result = this.valuesStorage.get(index);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::clone(LSL_PlainArray<?::T>) -> LSL_PlainArray<?::T>
     * Source: ohos/util/PlainArray.main.lsl:177 */
    clone(): PlainArray<T> {
        let result: PlainArray<T> = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The clone method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let keysStorageCopy: SymbolicList<number> = Engine.makeSymbolicList();
            this.keysStorage.copy(keysStorageCopy, 0, 0, this.keysStorage.size());
            let valuesStorageCopy: SymbolicList<T> = Engine.makeSymbolicList();
            this.valuesStorage.copy(valuesStorageCopy, 0, 0, this.valuesStorage.size());
            libsl.constructor_called_by_user = false;
            let lsl$na0 = new PlainArrayAutomaton_<T>(
            );
            libsl.constructor_called_by_user = true;
            // lsl$na0.__$state = Initialized;
            lsl$na0.valuesStorage = valuesStorageCopy;
            lsl$na0.keysStorage = keysStorageCopy;
            result = lsl$na0 as any as PlainArray<T>;
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::add(LSL_PlainArray<?::T>, number, ?::T) -> void
     * Source: ohos/util/PlainArray.main.lsl:195 */
    add(key: number, value: T) {
        /* body */ {
            let msg: string = "The add method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let size: number = this.keysStorage.size();
            Engine.assume(size === this.valuesStorage.size());
            this.keysStorage.insert(size, key);
            this.valuesStorage.insert(size, value);
        }
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::remove(LSL_PlainArray<?::T>, number) -> ?::T | undefined
     * Source: ohos/util/PlainArray.main.lsl:208 */
    remove(key: number): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The remove method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let size: number = this.keysStorage.size();
            if (size === 0) {
                result = undefined;
            }
            else {
                let index: number = libsl.ListActions.find(this.keysStorage, key, 0, size);
                if (index === -1) {
                    result = undefined;
                }
                else {
                    result = this.valuesStorage.get(index);
                    this.keysStorage.remove(index);
                    this.valuesStorage.remove(index);
                }
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::removeAt(LSL_PlainArray<?::T>, number) -> ?::T | undefined
     * Source: ohos/util/PlainArray.main.lsl:236 */
    removeAt(index: number): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The removeAt method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if ((index < 0) || (this.keysStorage.size() <= index)) {
                result = undefined;
            }
            else {
                result = this.valuesStorage.get(index);
                this.keysStorage.remove(index);
                this.valuesStorage.remove(index);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::removeRangeFrom(LSL_PlainArray<?::T>, number, number) -> number
     * Source: ohos/util/PlainArray.main.lsl:256 */
    removeRangeFrom(index: number, size: number): number {
        let result: number = 0;
        /* body */ {
            let msg: string = "The removeRangeFrom method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if ((index < 0) || (this.keysStorage.size() < (index + size))) {
            }
            else {
                let iBegin: number = (index + size) - 1;
                let iEnd: number = index - 1;
                result = size;
                let i: number = 0;
                for (i = iBegin; i > iEnd; i += -1) {
                    this.keysStorage.remove(i);
                }
                for (i = iBegin; i > iEnd; i += -1) {
                    this.valuesStorage.remove(i);
                }
                Engine.assume(this.keysStorage.size() === this.valuesStorage.size());
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::setValueAt(LSL_PlainArray<?::T>, number, ?::T) -> void
     * Source: ohos/util/PlainArray.main.lsl:295 */
    setValueAt(index: number, value: T) {
        /* body */ {
            let msg: string = "The setValueAt method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if ((index < 0) || (this.keysStorage.size() < index)) {
                throw libsl.new_ERROR("BusinessError", 10200001, "The value of index is out of range.");
            }
            this.valuesStorage.set(index, value);
        }
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::toString(LSL_PlainArray<?::T>) -> String
     * Source: ohos/util/PlainArray.main.lsl:307 */
    toString(): String {
        let result: String = '';
        /* body */ {
            let msg: string = "The toString method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = "";
            let size: number = this.keysStorage.size();
            if (size !== 0) {
                let i: number = 0;
                for (i = 0; i < size; i += 1) {
                    if (i > 0) {
                        result = result + ",";
                    }
                    let key: number = this.keysStorage.get(i);
                    let value: T = this.valuesStorage.get(i);
                    result = result + libsl.toString_any(key);
                    result = result + ":";
                    result = result + libsl.toString_any(value);
                }
            }
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::clear(LSL_PlainArray<?::T>) -> void
     * Source: ohos/util/PlainArray.main.lsl:339 */
    clear() {
        /* body */ {
            let msg: string = "The clear method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            this.keysStorage = Engine.makeSymbolicList();
            this.valuesStorage = Engine.makeSymbolicList();
            Engine.assume(this.keysStorage.size() === this.valuesStorage.size());
        }
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::forEach(LSL_PlainArray<?::T>, PlainArray_Consumer<?::T>, Object) -> void
     * Source: ohos/util/PlainArray.main.lsl:350 */
    forEach(callbackFn: (t: T, index?: number, arr?: PlainArray<T>) => void, thisArg?: Object) {
        /* body */ {
            let msg: string = "The forEach method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let i: number = 0;
            for (i = 0; i < this.keysStorage.size(); i += 1) {
                let index: number = this.keysStorage.get(i);
                let item: T = this.valuesStorage.get(i);
                callbackFn.call(thisArg, item, index, this);
            }
        }
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::[Symbol.iterator](LSL_PlainArray<?::T>) -> IterableIterator<tuple<number, ?::T>>
     * Source: ohos/util/PlainArray.main.lsl:370 */
    [Symbol.iterator](): IterableIterator<[number, T]> {
        let result: IterableIterator<[number, T]> = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The Symbol.iterator method cannot be bound.";
            if (!(this instanceof PlainArray)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na1 = new PlainArray_Iterator_tupleKV_Automaton<number, T>();
            // lsl$na1.__$state = Initialized;
            lsl$na1.cursor = 0;
            lsl$na1.keys = this.keysStorage;
            lsl$na1.values = this.valuesStorage;
            result = lsl$na1 as any as PlainArray_Iterator_tupleKV<number, T>;
        }
        return result;
    }

    /**
     * [FUNCTION] PlainArrayAutomaton::length(LSL_PlainArray<?::T>) -> number
     * Source: ohos/util/PlainArray.main.lsl:385 */
    get length(): number {
        let result: number = 0;
        /* body */ {
            result = this.keysStorage.size();
        }
        return result;
    }

}
