// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - ohos/util/TreeMap.lsl:27
//  - ohos/util/TreeMap.main.lsl:17
//
import {LSL_MapIterator_K} from './LSL_MapIterator_K';
import {LSL_MapIterator_K_Automaton} from './LSL_MapIterator_K_Automaton';
import {LSL_MapIterator_V} from './LSL_MapIterator_V';
import {LSL_MapIterator_V_Automaton} from './LSL_MapIterator_V_Automaton';
import {LSL_MapIterator_tupleKV} from './LSL_MapIterator_tupleKV';
import {LSL_MapIterator_tupleKV_Automaton} from './LSL_MapIterator_tupleKV_Automaton';
import {TreeMapAutomaton as TreeMapAutomaton_} from './TreeMapAutomaton';
import {libsl} from './libsl_runtime';
import {TreeMap} from '@ohos.util.TreeMap';
import {Approximate} from '@org.jacodb.approximation.annotation';
import {Engine} from '@org.usvm.api';


/**
 * TreeMapAutomaton for LSL_TreeMap<K, V> ~> TreeMap@@ohos.util.TreeMap */
@Approximate(/* value */ TreeMap)
export class TreeMapAutomaton<K, V> {

    storage: libsl.LSLMap<K, V> = libsl.ANYTHING;

    public constructor(c: (a: K, b: K) => boolean | undefined) {
        if (libsl.constructor_called_by_user) {
            // body
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200012, "The TreeMap\'s constructor cannot be directly invoked.");
            }
            this.storage = new libsl.LSLMap(new libsl.HashMapContainer());
        }
    }

    /**
     * [FUNCTION] TreeMapAutomaton::isEmpty(LSL_TreeMap<?::K, ?::V>) -> boolean
     * Source: ohos/util/TreeMap.main.lsl:82 */
    isEmpty(): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The isEmpty method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.storage.size() === 0;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::hasKey(LSL_TreeMap<?::K, ?::V>, ?::K) -> boolean
     * Source: ohos/util/TreeMap.main.lsl:91 */
    hasKey(key: K): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The hasKey method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = false;
            }
            else {
                result = this.storage.hasKey(key);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::hasValue(LSL_TreeMap<?::K, ?::V>, ?::V) -> boolean
     * Source: ohos/util/TreeMap.main.lsl:103 */
    hasValue(value: V): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The hasValue method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = false;
            let storageSize: number = this.storage.size();
            if (storageSize !== 0) {
                const unseen: libsl.LSLMap<K, V> = this.storage.duplicate();
                while (storageSize !== 0) {
                    const curKey: K = unseen.anyKey();
                    const curValue: V = this.storage.get(curKey);
                    if (libsl.equals_any_any(curValue, value)) {
                        result = true;
                        break;
                    }
                    unseen.remove(curKey);
                    storageSize -= 1;
                }
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::get(LSL_TreeMap<?::K, ?::V>, ?::K) -> ?::V | undefined
     * Source: ohos/util/TreeMap.main.lsl:138 */
    get(key: K): V | undefined {
        let result: V | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The get method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.hasKey(key)) {
                result = this.storage.get(key);
            }
            else {
                result = undefined;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::getFirstKey(LSL_TreeMap<?::K, ?::V>) -> ?::K | undefined
     * Source: ohos/util/TreeMap.main.lsl:150 */
    getFirstKey(): K | undefined {
        let result: K | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The getFirstKey method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::getLastKey(LSL_TreeMap<?::K, ?::V>) -> ?::K | undefined
     * Source: ohos/util/TreeMap.main.lsl:162 */
    getLastKey(): K | undefined {
        let result: K | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The getLastKey method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::setAll(LSL_TreeMap<?::K, ?::V>, LSL_TreeMap<?::K, ?::V>) -> void
     * Source: ohos/util/TreeMap.main.lsl:174 */
    setAll(map: TreeMap<K, V>) {
        /* body */ {
            const msg: string = "The setAll method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            const otherMapStorage: libsl.LSLMap<K, V> = (map as any as TreeMapAutomaton_<K, V>).storage;
            let otherSize: number = otherMapStorage.size();
            if (otherSize !== 0) {
                Engine.assume(otherSize > 0);
                const unseenOther: libsl.LSLMap<K, V> = otherMapStorage.duplicate();
                while (otherSize !== 0) {
                    const key: K = unseenOther.anyKey();
                    const value: V = unseenOther.get(key);
                    this.storage.set(key, value);
                    unseenOther.remove(key);
                    otherSize -= 1;
                }
            }
        }
    }

    /**
     * [FUNCTION] TreeMapAutomaton::set(LSL_TreeMap<?::K, ?::V>, ?::K, ?::V) -> Object
     * Source: ohos/util/TreeMap.main.lsl:206 */
    set(key: K, value: V): Object {
        let result: Object = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The set method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this;
            this.storage.set(key, value);
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::remove(LSL_TreeMap<?::K, ?::V>, ?::K) -> ?::V | undefined
     * Source: ohos/util/TreeMap.main.lsl:216 */
    remove(key: K): V | undefined {
        let result: V | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The remove method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.hasKey(key)) {
                result = this.storage.get(key);
                this.storage.remove(key);
            }
            else {
                result = undefined;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::getLowerKey(LSL_TreeMap<?::K, ?::V>, ?::K) -> ?::K | undefined
     * Source: ohos/util/TreeMap.main.lsl:237 */
    getLowerKey(key: K): K | undefined {
        let result: K | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The getLowerKey method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::getHigherKey(LSL_TreeMap<?::K, ?::V>, ?::K) -> ?::K | undefined
     * Source: ohos/util/TreeMap.main.lsl:251 */
    getHigherKey(key: K): K | undefined {
        let result: K | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The getLowerKey method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::replace(LSL_TreeMap<?::K, ?::V>, ?::K, ?::V) -> boolean
     * Source: ohos/util/TreeMap.main.lsl:263 */
    replace(key: K, newValue: V): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The replace method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.storage.hasKey(key);
            if (result) {
                this.storage.set(key, newValue);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::clear(LSL_TreeMap<?::K, ?::V>) -> void
     * Source: ohos/util/TreeMap.main.lsl:274 */
    clear() {
        /* body */ {
            const msg: string = "The clear method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            this.storage = new libsl.LSLMap(new libsl.HashMapContainer());
        }
    }

    /**
     * [FUNCTION] TreeMapAutomaton::keys(LSL_TreeMap<?::K, ?::V>) -> IterableIterator<?::K>
     * Source: ohos/util/TreeMap.main.lsl:283 */
    keys(): IterableIterator<K> {
        let result: IterableIterator<K> = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The keys method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na0 = new LSL_MapIterator_K_Automaton<K>();
            // lsl$na0.__$state = Initialized;
            lsl$na0.unseen = this.storage.duplicate();
            result = lsl$na0 as any as LSL_MapIterator_K<K>;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::values(LSL_TreeMap<?::K, ?::V>) -> IterableIterator<?::V>
     * Source: ohos/util/TreeMap.main.lsl:294 */
    values(): IterableIterator<V> {
        let result: IterableIterator<V> = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The values method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na1 = new LSL_MapIterator_V_Automaton<V>();
            // lsl$na1.__$state = Initialized;
            lsl$na1.unseen = this.storage.duplicate();
            result = lsl$na1 as any as LSL_MapIterator_V<V>;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::forEach(LSL_TreeMap<?::K, ?::V>, TreeMap_Callback<?::K, ?::V>, Object) -> void
     * Source: ohos/util/TreeMap.main.lsl:305 */
    forEach(callbackFn: (value?: V, key?: K, map?: TreeMap<K, V>) => void, thisArg?: Object) {
        /* body */ {
            const msg: string = "The forEach method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let storageSize: number = this.storage.size();
            if (storageSize > 0) {
                const unseen: libsl.LSLMap<K, V> = this.storage.duplicate();
                storageSize = unseen.size();
                Engine.assume(storageSize > 0);
                let i: number = 0;
                for (i = 0; i < storageSize; i += 1) {
                    const key: K = unseen.anyKey();
                    const value: V = this.storage.get(key);
                    callbackFn.call(thisArg, value, key, this);
                    unseen.remove(key);
                }
            }
        }
    }

    /**
     * [FUNCTION] TreeMapAutomaton::entries(LSL_TreeMap<?::K, ?::V>) -> IterableIterator<tuple<?::K, ?::V>>
     * Source: ohos/util/TreeMap.main.lsl:339 */
    entries(): IterableIterator<[K, V]> {
        let result: IterableIterator<[K, V]> = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The entries method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na2 = new LSL_MapIterator_tupleKV_Automaton<K, V>();
            // lsl$na2.__$state = Initialized;
            lsl$na2.unseen = this.storage.duplicate();
            result = lsl$na2 as any as LSL_MapIterator_tupleKV<K, V>;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::[Symbol.iterator](LSL_TreeMap<?::K, ?::V>) -> IterableIterator<tuple<?::K, ?::V>>
     * Source: ohos/util/TreeMap.main.lsl:350 */
    [Symbol.iterator](): IterableIterator<[K, V]> {
        let result: IterableIterator<[K, V]> = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The Symbol.iterator method cannot be bound.";
            if (!(this instanceof TreeMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na3 = new LSL_MapIterator_tupleKV_Automaton<K, V>();
            // lsl$na3.__$state = Initialized;
            lsl$na3.unseen = this.storage.duplicate();
            result = lsl$na3 as any as LSL_MapIterator_tupleKV<K, V>;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeMapAutomaton::length(LSL_TreeMap<?::K, ?::V>) -> number
     * Source: ohos/util/TreeMap.main.lsl:363 */
    get length(): number {
        let result: number = 0;
        /* body */ {
            result = this.storage.size();
        }
        return result;
    }

}
