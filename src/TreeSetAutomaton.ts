// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - ohos/util/TreeSet.lsl:15
//  - ohos/util/TreeSet.main.lsl:18
//
import {LSL_MapIterator_K} from './LSL_MapIterator_K';
import {LSL_MapIterator_K_Automaton} from './LSL_MapIterator_K_Automaton';
import {LSL_MapIterator_tupleKK} from './LSL_MapIterator_tupleKK';
import {LSL_MapIterator_tupleKK_Automaton} from './LSL_MapIterator_tupleKK_Automaton';
import {libsl} from './libsl_runtime';
import {TreeSet} from '@ohos.util.TreeSet';
import {Approximate} from '@org.jacodb.approximation.annotation';
import {Engine} from '@org.usvm.api';


/**
 * TreeSetAutomaton for TreeSet<T> ~> TreeSet@@ohos.util.TreeSet */
@Approximate(/* value */ TreeSet)
export class TreeSetAutomaton<T> {

    storage: libsl.LSLMap<T, T> = libsl.ANYTHING;

    public constructor(c: (a: T, b: T) => boolean | undefined) {
        if (libsl.constructor_called_by_user) {
            // body
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200012, "The TreeSet\'s constructor cannot be directly invoked.");
            }
            this.storage = new libsl.LSLMap(new libsl.HashMapContainer());
        }
    }

    /**
     * [FUNCTION] TreeSetAutomaton::isEmpty(TreeSet<?::T>) -> boolean
     * Source: ohos/util/TreeSet.main.lsl:80 */
    isEmpty(): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The isEmpty method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.storage.size() === 0;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::has(TreeSet<?::T>, ?::T) -> boolean
     * Source: ohos/util/TreeSet.main.lsl:89 */
    has(value: T): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The has method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = false;
            }
            else {
                result = this.storage.hasKey(value);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::getFirstValue(TreeSet<?::T>) -> ?::T | undefined
     * Source: ohos/util/TreeSet.main.lsl:101 */
    getFirstValue(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The getFirstValue method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::getLastValue(TreeSet<?::T>) -> ?::T | undefined
     * Source: ohos/util/TreeSet.main.lsl:113 */
    getLastValue(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The getLastValue method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::add(TreeSet<?::T>, ?::T) -> boolean
     * Source: ohos/util/TreeSet.main.lsl:125 */
    add(value: T): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The add method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.hasKey(value)) {
                result = false;
            }
            else {
                this.storage.set(value, value);
                result = true;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::remove(TreeSet<?::T>, ?::T) -> boolean
     * Source: ohos/util/TreeSet.main.lsl:142 */
    remove(value: T): boolean {
        let result: boolean = false;
        /* body */ {
            const msg: string = "The remove method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.storage.hasKey(value);
            if (result) {
                this.storage.remove(value);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::getLowerValue(TreeSet<?::T>) -> ?::T | undefined
     * Source: ohos/util/TreeSet.main.lsl:153 */
    getLowerValue(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The getLowerValue method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::getHigherValue(TreeSet<?::T>) -> ?::T | undefined
     * Source: ohos/util/TreeSet.main.lsl:165 */
    getHigherValue(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The getHigherValue method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::popFirst(TreeSet<?::T>) -> ?::T | undefined
     * Source: ohos/util/TreeSet.main.lsl:177 */
    popFirst(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The popFirst method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
                this.storage.remove(result);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::popLast(TreeSet<?::T>) -> ?::T | undefined
     * Source: ohos/util/TreeSet.main.lsl:194 */
    popLast(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The popLast method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.anyKey();
                this.storage.remove(result);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::clear(TreeSet<?::T>) -> void
     * Source: ohos/util/TreeSet.main.lsl:211 */
    clear() {
        /* body */ {
            const msg: string = "The clear method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            this.storage = new libsl.LSLMap(new libsl.HashMapContainer());
        }
    }

    /**
     * [FUNCTION] TreeSetAutomaton::values(TreeSet<?::T>) -> IterableIterator<?::T>
     * Source: ohos/util/TreeSet.main.lsl:220 */
    values(): IterableIterator<T> {
        let result: IterableIterator<T> = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The values method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na0 = new LSL_MapIterator_K_Automaton<T>();
            // lsl$na0.__$state = Initialized;
            lsl$na0.unseen = this.storage.duplicate();
            result = lsl$na0 as any as LSL_MapIterator_K<T>;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::forEach(TreeSet<?::T>, TreeSet_Callback<?::T>, Object) -> void
     * Source: ohos/util/TreeSet.main.lsl:231 */
    forEach(callbackFn: (value?: T, key?: T, instance?: TreeSet<T>) => void, thisArg?: Object) {
        /* body */ {
            const msg: string = "The forEach method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let storageSize: number = this.storage.size();
            if (storageSize > 0) {
                const unseen: libsl.LSLMap<T, any> = this.storage.duplicate();
                storageSize = unseen.size();
                Engine.assume(storageSize > 0);
                let i: number = 0;
                for (i = 0; i < storageSize; i += 1) {
                    const value: T = unseen.anyKey();
                    callbackFn.call(thisArg, value, value, this);
                    unseen.remove(value);
                }
            }
        }
    }

    /**
     * [FUNCTION] TreeSetAutomaton::entries(TreeSet<?::T>) -> IterableIterator<tuple<?::T, ?::T>>
     * Source: ohos/util/TreeSet.main.lsl:261 */
    entries(): IterableIterator<[T, T]> {
        let result: IterableIterator<[T, T]> = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The entries method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na1 = new LSL_MapIterator_tupleKK_Automaton<T>();
            // lsl$na1.__$state = Initialized;
            lsl$na1.unseen = this.storage.duplicate();
            result = lsl$na1 as any as LSL_MapIterator_tupleKK<T>;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::[Symbol.iterator](TreeSet<?::T>) -> IterableIterator<?::T>
     * Source: ohos/util/TreeSet.main.lsl:272 */
    [Symbol.iterator](): IterableIterator<T> {
        let result: IterableIterator<T> = libsl.ANYTHING;
        /* body */ {
            const msg: string = "The Symbol.iterator method cannot be bound.";
            if (!(this instanceof TreeSet)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na2 = new LSL_MapIterator_K_Automaton<T>();
            // lsl$na2.__$state = Initialized;
            lsl$na2.unseen = this.storage.duplicate();
            result = lsl$na2 as any as LSL_MapIterator_K<T>;
        }
        return result;
    }

    /**
     * [FUNCTION] TreeSetAutomaton::length(TreeSet<?::T>) -> number
     * Source: ohos/util/TreeSet.main.lsl:285 */
    get length(): number {
        let result: number = 0;
        /* body */ {
            result = this.storage.size();
        }
        return result;
    }

}
