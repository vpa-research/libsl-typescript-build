// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - libsl/LSL_ListIterator.lsl:15
//  - libsl/LSL_ListIterator.main.lsl:17
//
import {LSL_IteratorResult} from './LSL_IteratorResult';
import {LSL_IteratorResultAutomaton} from './LSL_IteratorResultAutomaton';
import {LSL_ListIterator} from './LSL_ListIterator';
import {libsl} from './libsl_runtime';
import {Approximate} from '@org.jacodb.approximation.annotation';
import {Engine, SymbolicList} from '@org.usvm.api';


/**
 * LSL_ListIteratorAutomaton for LSL_ListIterator<T> ~> LSL_ListIterator@LSL_ListIterator */
@Approximate(/* value */ LSL_ListIterator)
export class LSL_ListIteratorAutomaton<T> {

    items: SymbolicList<T> = libsl.ANYTHING;

    cursor: number = 0;

    /**
     * [FUNCTION] LSL_ListIteratorAutomaton::next(LSL_ListIterator<?::T>) -> IteratorResult<?::T>
     * Source: libsl/LSL_ListIterator.main.lsl:37 */
    next(): IteratorResult<T> {
        let result: IteratorResult<T> = libsl.ANYTHING;
        /* body */ {
            let pos: number = this.cursor;
            let isDone: boolean = false;
            let value: T | undefined = undefined;
            if (pos < this.items.size()) {
                Engine.assume(pos >= 0);
                this.cursor = pos + 1;
                value = this.items.get(pos);
                isDone = true;
            }
            result = (() => {
                // FIXME: this should not be an expression
                libsl.constructor_called_by_user = false;
                let lsl$na = new LSL_IteratorResultAutomaton<T>();
                libsl.constructor_called_by_user = true;
                // lsl$na.__$state = Initialized;
                lsl$na.done = isDone;
                lsl$na.value = value;
                return lsl$na as any as LSL_IteratorResult<T>;
            })();
        }
        return result;
    }

}
