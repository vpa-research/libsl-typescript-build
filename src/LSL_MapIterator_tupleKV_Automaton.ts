// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - libsl/LSL_MapIterator.lsl:45
//  - libsl/LSL_MapIterator_tupleKV.main.lsl:18
//
import {LSL_IteratorResult} from './LSL_IteratorResult';
import {LSL_IteratorResultAutomaton} from './LSL_IteratorResultAutomaton';
import {LSL_MapIterator_tupleKV} from './LSL_MapIterator_tupleKV';
import {libsl} from './libsl_runtime';
import {Approximate} from '@org.jacodb.approximation.annotation';


/**
 * LSL_MapIterator_tupleKV_Automaton for LSL_MapIterator_tupleKV<K, V> ~> LSL_MapIterator_tupleKV@LSL_MapIterator_tupleKV */
@Approximate(/* value */ LSL_MapIterator_tupleKV)
export class LSL_MapIterator_tupleKV_Automaton<K, V> {

    unseen: libsl.LSLMap<K, V> = libsl.ANYTHING;

    /**
     * [FUNCTION] LSL_MapIterator_tupleKV_Automaton::next(LSL_MapIterator_tupleKV<?::K, ?::V>) -> IteratorResult<tuple<?::K, ?::V>>
     * Source: libsl/LSL_MapIterator_tupleKV.main.lsl:35 */
    next(): IteratorResult<[K, V]> {
        let result: IteratorResult<[K, V]> = libsl.ANYTHING;
        /* body */ {
            let iteratorDone: boolean = true;
            let iteratorValue: [K, V] | undefined = undefined;
            if (this.unseen.size() !== 0) {
                let key: K = this.unseen.anyKey();
                let value: V = this.unseen.get(key);
                this.unseen.remove(key);
                iteratorDone = false;
                iteratorValue = [ key, value ];
            }
            let lsl$na0 = new LSL_IteratorResultAutomaton<[K, V]>();
            // lsl$na0.__$state = Initialized;
            lsl$na0.value = iteratorValue;
            lsl$na0.done = iteratorDone;
            result = lsl$na0 as any as LSL_IteratorResult<[K, V]>;
        }
        return result;
    }

}
