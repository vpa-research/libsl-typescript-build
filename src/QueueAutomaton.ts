// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - ohos/util/Queue.lsl:26
//  - ohos/util/Queue.main.lsl:18
//
import {LSL_ListIterator} from './LSL_ListIterator';
import {LSL_ListIteratorAutomaton} from './LSL_ListIteratorAutomaton';
import {libsl} from './libsl_runtime';
import {Queue} from '@ohos.util.Queue';
import {Approximate} from '@org.jacodb.approximation.annotation';
import {Engine, SymbolicList} from '@org.usvm.api';


/**
 * QueueAutomaton for LSL_Queue<T> ~> Queue@@ohos.util.Queue */
@Approximate(/* value */ Queue)
export class QueueAutomaton<T> {

    storage: SymbolicList<T> = libsl.ANYTHING;

    public constructor() {
        if (libsl.constructor_called_by_user) {
            // body
            if (!(this instanceof Queue)) {
                throw libsl.new_ERROR("BusinessError", 10200012, "The Queue\'s constructor cannot be directly invoked.");
            }
            this.storage = Engine.makeSymbolicList();
        }
    }

    /**
     * [FUNCTION] QueueAutomaton::add(LSL_Queue<?::T>, ?::T) -> boolean
     * Source: ohos/util/Queue.main.lsl:62 */
    add(element: T): boolean {
        let result: boolean = false;
        /* body */ {
            let msg: string = "The add method cannot be bound.";
            if (!(this instanceof Queue)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            this.storage.insert(this.storage.size(), element);
            result = true;
        }
        return result;
    }

    /**
     * [FUNCTION] QueueAutomaton::pop(LSL_Queue<?::T>) -> ?::T
     * Source: ohos/util/Queue.main.lsl:74 */
    pop(): T {
        let result: T = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The pop method cannot be bound.";
            if (!(this instanceof Queue)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.storage.get(0);
            this.storage.remove(0);
        }
        return result;
    }

    /**
     * [FUNCTION] QueueAutomaton::getFirst(LSL_Queue<?::T>) -> ?::T
     * Source: ohos/util/Queue.main.lsl:88 */
    getFirst(): T {
        let result: T = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The getFirst method cannot be bound.";
            if (!(this instanceof Queue)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.storage.get(0);
        }
        return result;
    }

    /**
     * [FUNCTION] QueueAutomaton::forEach(LSL_Queue<?::T>, Queue_ConsumerCallback<?::T>, Object) -> void
     * Source: ohos/util/Queue.main.lsl:97 */
    forEach(callbackFn: (value: T, index?: number, queue?: Queue<T>) => void, thisArg?: Object) {
        /* body */ {
            let msg: string = "The forEach method cannot be bound.";
            if (!(this instanceof Queue)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let i: number = 0;
            for (i = 0; i < this.storage.size(); i += 1) {
                let item: T = this.storage.get(i);
                callbackFn.call(thisArg, item, i, this);
            }
        }
    }

    /**
     * [FUNCTION] QueueAutomaton::[Symbol.iterator](LSL_Queue<?::T>) -> Iterator<?::T>
     * Source: ohos/util/Queue.main.lsl:116 */
    [Symbol.iterator](): Iterator<T> {
        let result: Iterator<T> = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The Symbol.iterator method cannot be bound.";
            if (!(this instanceof Queue)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = (() => {
                // FIXME: this should not be an expression
                libsl.constructor_called_by_user = false;
                let lsl$na = new LSL_ListIteratorAutomaton<T>();
                libsl.constructor_called_by_user = true;
                // lsl$na.__$state = Initialized;
                lsl$na.cursor = 0;
                lsl$na.items = this.storage;
                return lsl$na as any as LSL_ListIterator<T>;
            })();
        }
        return result;
    }

}
