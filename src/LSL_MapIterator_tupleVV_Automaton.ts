// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - libsl/LSL_MapIterator.lsl:56
//  - libsl/LSL_MapIterator_tupleVV.main.lsl:18
//
import {LSL_IteratorResult} from './LSL_IteratorResult';
import {LSL_IteratorResultAutomaton} from './LSL_IteratorResultAutomaton';
import {LSL_MapIterator_tupleVV} from './LSL_MapIterator_tupleVV';
import {libsl} from './libsl_runtime';
import {Approximate} from '@org.jacodb.approximation.annotation';


/**
 * LSL_MapIterator_tupleVV_Automaton for LSL_MapIterator_tupleVV<V> ~> LSL_MapIterator_tupleVV@LSL_MapIterator_tupleVV */
@Approximate(/* value */ LSL_MapIterator_tupleVV)
export class LSL_MapIterator_tupleVV_Automaton<V> {

    unseen: libsl.LSLMap<any, V> = libsl.ANYTHING;

    /**
     * [FUNCTION] LSL_MapIterator_tupleVV_Automaton::next(LSL_MapIterator_tupleVV<?::V>) -> IteratorResult<tuple<?::V, ?::V>>
     * Source: libsl/LSL_MapIterator_tupleVV.main.lsl:35 */
    next(): IteratorResult<[V, V]> {
        let result: IteratorResult<[V, V]> = libsl.ANYTHING;
        /* body */ {
            let iteratorDone: boolean = true;
            let iteratorValue: [V, V] | undefined = undefined;
            if (this.unseen.size() !== 0) {
                let key: any = this.unseen.anyKey();
                let value: V = this.unseen.get(key);
                this.unseen.remove(key);
                iteratorDone = false;
                iteratorValue = [ value, value ];
            }
            let lsl$na0 = new LSL_IteratorResultAutomaton<[V, V]>();
            // lsl$na0.__$state = Initialized;
            lsl$na0.value = iteratorValue;
            lsl$na0.done = iteratorDone;
            result = lsl$na0 as any as LSL_IteratorResult<[V, V]>;
        }
        return result;
    }

}
