// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - ohos/util/HashMap.lsl:27
//  - ohos/util/HashMap.main.lsl:17
//
import {HashMapAutomaton as HashMapAutomaton_} from './HashMapAutomaton';
import {LSL_MapIterator_K} from './LSL_MapIterator_K';
import {LSL_MapIterator_K_Automaton} from './LSL_MapIterator_K_Automaton';
import {LSL_MapIterator_V} from './LSL_MapIterator_V';
import {LSL_MapIterator_V_Automaton} from './LSL_MapIterator_V_Automaton';
import {LSL_MapIterator_tupleKV} from './LSL_MapIterator_tupleKV';
import {LSL_MapIterator_tupleKV_Automaton} from './LSL_MapIterator_tupleKV_Automaton';
import {libsl} from './libsl_runtime';
import {HashMap} from '@ohos.util.HashMap';
import {Approximate} from '@org.jacodb.approximation.annotation';


/**
 * HashMapAutomaton for LSL_HashMap<K, V> ~> HashMap@@ohos.util.HashMap */
@Approximate(/* value */ HashMap)
export class HashMapAutomaton<K, V> {

    storage: libsl.LSLMap<K, V> = libsl.ANYTHING;

    public constructor() {
        if (libsl.constructor_called_by_user) {
            // body
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200012, "The HashMap\'s constructor cannot be directly invoked.");
            }
            this.storage = new libsl.LSLMap(new libsl.HashMapContainer());
        }
    }

    /**
     * [FUNCTION] HashMapAutomaton::isEmpty(LSL_HashMap<?::K, ?::V>) -> boolean
     * Source: ohos/util/HashMap.main.lsl:78 */
    isEmpty(): boolean {
        let result: boolean = false;
        /* body */ {
            let msg: string = "The isEmpty method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this.storage.size() === 0;
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::hasKey(LSL_HashMap<?::K, ?::V>, ?::K) -> boolean
     * Source: ohos/util/HashMap.main.lsl:87 */
    hasKey(key: K): boolean {
        let result: boolean = false;
        /* body */ {
            let msg: string = "The hasKey method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = false;
            }
            else {
                result = this.storage.hasKey(key);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::hasValue(LSL_HashMap<?::K, ?::V>, ?::V) -> boolean
     * Source: ohos/util/HashMap.main.lsl:99 */
    hasValue(value: V): boolean {
        let result: boolean = false;
        /* body */ {
            let msg: string = "The hasValue method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = false;
            let storageSize: number = this.storage.size();
            if (storageSize !== 0) {
                let unseen: libsl.LSLMap<K, V> = this.storage.duplicate();
                while (storageSize !== 0) {
                    let curKey: K = unseen.anyKey();
                    let curValue: V = this.storage.get(curKey);
                    if (libsl.equals_any_any(curValue, value)) {
                        result = true;
                        break;
                    }
                    unseen.remove(curKey);
                    storageSize -= 1;
                }
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::get(LSL_HashMap<?::K, ?::V>, ?::K) -> ?::V
     * Source: ohos/util/HashMap.main.lsl:134 */
    get(key: K): V {
        let result: V = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The get method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.hasKey(key)) {
                result = this.storage.get(key);
            }
            else {
                result = ((undefined as any) as V);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::setAll(LSL_HashMap<?::K, ?::V>, LSL_HashMap<?::K, ?::V>) -> void
     * Source: ohos/util/HashMap.main.lsl:147 */
    setAll(map: HashMap<K, V>) {
        /* body */ {
            let msg: string = "The setAll method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let otherMapStorage: libsl.LSLMap<K, V> = (map as any as HashMapAutomaton_<K, V>).storage;
            let otherSize: number = otherMapStorage.size();
            if (otherSize !== 0) {
                let unseenOther: libsl.LSLMap<K, V> = otherMapStorage.duplicate();
                while (otherSize !== 0) {
                    let key: K = unseenOther.anyKey();
                    let value: V = unseenOther.get(key);
                    this.storage.set(key, value);
                    unseenOther.remove(key);
                    otherSize -= 1;
                }
            }
        }
    }

    /**
     * [FUNCTION] HashMapAutomaton::set(LSL_HashMap<?::K, ?::V>, ?::K, ?::V) -> Object | undefined
     * Source: ohos/util/HashMap.main.lsl:177 */
    set(key: K, value: V): Object | undefined {
        let result: Object | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The set method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = this;
            this.storage.set(key, value);
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::remove(LSL_HashMap<?::K, ?::V>, ?::K) -> ?::V
     * Source: ohos/util/HashMap.main.lsl:187 */
    remove(key: K): V {
        let result: V = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The remove method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.hasKey(key)) {
                result = this.storage.get(key);
                this.storage.remove(key);
            }
            else {
                result = ((undefined as any) as V);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::clear(LSL_HashMap<?::K, ?::V>) -> void
     * Source: ohos/util/HashMap.main.lsl:206 */
    clear() {
        /* body */ {
            let msg: string = "The clear method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            this.storage = new libsl.LSLMap(new libsl.HashMapContainer());
        }
    }

    /**
     * [FUNCTION] HashMapAutomaton::keys(LSL_HashMap<?::K, ?::V>) -> IterableIterator<?::K>
     * Source: ohos/util/HashMap.main.lsl:215 */
    keys(): IterableIterator<K> {
        let result: IterableIterator<K> = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The keys method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na0 = new LSL_MapIterator_K_Automaton<K>();
            // lsl$na0.__$state = Initialized;
            lsl$na0.unseen = this.storage.duplicate();
            result = lsl$na0 as any as LSL_MapIterator_K<K>;
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::values(LSL_HashMap<?::K, ?::V>) -> IterableIterator<?::V>
     * Source: ohos/util/HashMap.main.lsl:226 */
    values(): IterableIterator<V> {
        let result: IterableIterator<V> = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The values method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na1 = new LSL_MapIterator_V_Automaton<V>();
            // lsl$na1.__$state = Initialized;
            lsl$na1.unseen = this.storage.duplicate();
            result = lsl$na1 as any as LSL_MapIterator_V<V>;
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::replace(LSL_HashMap<?::K, ?::V>, ?::K, ?::V) -> boolean
     * Source: ohos/util/HashMap.main.lsl:237 */
    replace(key: K, newValue: V): boolean {
        let result: boolean = false;
        /* body */ {
            let msg: string = "The replace method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.hasKey(key)) {
                this.storage.set(key, newValue);
                result = true;
            }
            else {
                result = false;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::forEach(LSL_HashMap<?::K, ?::V>, HashMap_Callback<?::K, ?::V>, Object) -> void
     * Source: ohos/util/HashMap.main.lsl:254 */
    forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) {
        /* body */ {
            let msg: string = "The forEach method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let storageSize: number = this.storage.size();
            if (storageSize !== 0) {
                let unseen: libsl.LSLMap<K, V> = this.storage.duplicate();
                while (storageSize !== 0) {
                    let key: K = unseen.anyKey();
                    let value: V = this.storage.get(key);
                    callbackFn.call(thisArg, value, key, this);
                    unseen.remove(key);
                    storageSize -= 1;
                }
            }
        }
    }

    /**
     * [FUNCTION] HashMapAutomaton::entries(LSL_HashMap<?::K, ?::V>) -> IterableIterator<tuple<?::K, ?::V>>
     * Source: ohos/util/HashMap.main.lsl:286 */
    entries(): IterableIterator<[K, V]> {
        let result: IterableIterator<[K, V]> = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The entries method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na2 = new LSL_MapIterator_tupleKV_Automaton<K, V>();
            // lsl$na2.__$state = Initialized;
            lsl$na2.unseen = this.storage.duplicate();
            result = lsl$na2 as any as LSL_MapIterator_tupleKV<K, V>;
        }
        return result;
    }

    /**
     * [FUNCTION] HashMapAutomaton::[Symbol.iterator](LSL_HashMap<?::K, ?::V>) -> IterableIterator<tuple<?::K, ?::V>>
     * Source: ohos/util/HashMap.main.lsl:297 */
    [Symbol.iterator](): IterableIterator<[K, V]> {
        let result: IterableIterator<[K, V]> = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The Symbol.iterator method cannot be bound.";
            if (!(this instanceof HashMap)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na3 = new LSL_MapIterator_tupleKV_Automaton<K, V>();
            // lsl$na3.__$state = Initialized;
            lsl$na3.unseen = this.storage.duplicate();
            result = lsl$na3 as any as LSL_MapIterator_tupleKV<K, V>;
        }
        return result;
    }

}
