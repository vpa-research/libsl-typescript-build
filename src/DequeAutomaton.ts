// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - ohos/util/Deque.lsl:26
//  - ohos/util/Deque.main.lsl:18
//
import {LSL_ListIterator} from './LSL_ListIterator';
import {LSL_ListIteratorAutomaton} from './LSL_ListIteratorAutomaton';
import {libsl} from './libsl_runtime';
import {Deque} from '@ohos.util.Deque';
import {Approximate} from '@org.jacodb.approximation.annotation';
import {Engine, SymbolicList} from '@org.usvm.api';


/**
 * DequeAutomaton for LSL_Deque<T> ~> Deque@@ohos.util.Deque */
@Approximate(/* value */ Deque)
export class DequeAutomaton<T> {

    storage: SymbolicList<T> = libsl.ANYTHING;

    public constructor() {
        if (libsl.constructor_called_by_user) {
            // body
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200012, "The Deque\'s constructor cannot be directly invoked.");
            }
            this.storage = Engine.makeSymbolicList();
        }
    }

    /**
     * [FUNCTION] DequeAutomaton::insertFront(LSL_Deque<?::T>, ?::T) -> void
     * Source: ohos/util/Deque.main.lsl:73 */
    insertFront(element: T) {
        /* body */ {
            let msg: string = "The insertFront method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            this.storage.insert(0, element);
        }
    }

    /**
     * [FUNCTION] DequeAutomaton::insertEnd(LSL_Deque<?::T>, ?::T) -> void
     * Source: ohos/util/Deque.main.lsl:82 */
    insertEnd(element: T) {
        /* body */ {
            let msg: string = "The insertEnd method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            this.storage.insert(this.storage.size(), element);
        }
    }

    /**
     * [FUNCTION] DequeAutomaton::has(LSL_Deque<?::T>, ?::T) -> boolean
     * Source: ohos/util/Deque.main.lsl:91 */
    has(element: T): boolean {
        let result: boolean = false;
        /* body */ {
            let msg: string = "The has method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            result = libsl.ListActions.find(this.storage, element, 0, this.storage.size()) !== -1;
        }
        return result;
    }

    /**
     * [FUNCTION] DequeAutomaton::popFirst(LSL_Deque<?::T>) -> ?::T | undefined
     * Source: ohos/util/Deque.main.lsl:100 */
    popFirst(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The popFirst method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.get(0);
                this.storage.remove(0);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] DequeAutomaton::popLast(LSL_Deque<?::T>) -> ?::T | undefined
     * Source: ohos/util/Deque.main.lsl:117 */
    popLast(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The popLast method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lastIndex: number = this.storage.size() - 1;
            if (lastIndex === -1) {
                result = undefined;
            }
            else {
                result = this.storage.get(lastIndex);
                this.storage.remove(lastIndex);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] DequeAutomaton::forEach(LSL_Deque<?::T>, Deque_Consumer<?::T>, Object) -> void
     * Source: ohos/util/Deque.main.lsl:135 */
    forEach(callbackFn: (value: T, index?: number, queue?: Deque<T>) => void, thisArg?: Object) {
        /* body */ {
            let msg: string = "The forEach method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let i: number = 0;
            for (i = 0; i < this.storage.size(); i += 1) {
                let item: T = this.storage.get(i);
                callbackFn.call(thisArg, item, i, this);
            }
        }
    }

    /**
     * [FUNCTION] DequeAutomaton::getFirst(LSL_Deque<?::T>) -> ?::T | undefined
     * Source: ohos/util/Deque.main.lsl:154 */
    getFirst(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The getFirst method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            if (this.storage.size() === 0) {
                result = undefined;
            }
            else {
                result = this.storage.get(0);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] DequeAutomaton::getLast(LSL_Deque<?::T>) -> ?::T | undefined
     * Source: ohos/util/Deque.main.lsl:166 */
    getLast(): T | undefined {
        let result: T | undefined = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The getLast method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let index: number = this.storage.size() - 1;
            if (index === -1) {
                result = undefined;
            }
            else {
                result = this.storage.get(index);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] DequeAutomaton::[Symbol.iterator](LSL_Deque<?::T>) -> IterableIterator<?::T>
     * Source: ohos/util/Deque.main.lsl:179 */
    [Symbol.iterator](): IterableIterator<T> {
        let result: IterableIterator<T> = libsl.ANYTHING;
        /* body */ {
            let msg: string = "The Symbol.iterator method cannot be bound.";
            if (!(this instanceof Deque)) {
                throw libsl.new_ERROR("BusinessError", 10200011, msg);
            }
            let lsl$na0 = new LSL_ListIteratorAutomaton<T>();
            // lsl$na0.__$state = Initialized;
            lsl$na0.container = this;
            lsl$na0.cursor = 0;
            result = lsl$na0 as any as LSL_ListIterator<T>;
        }
        return result;
    }

    /**
     * [FUNCTION] DequeAutomaton::length(LSL_Deque<?::T>) -> number
     * Source: ohos/util/Deque.main.lsl:193 */
    get length(): number {
        let result: number = 0;
        /* body */ {
            result = this.storage.size();
        }
        return result;
    }

}
